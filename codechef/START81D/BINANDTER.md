The given no. `n` has to be represented as sum of powers of 2 and 3, each occurring only once. (ie 1458 cannot be represented as 729 + 729 , as 729 (3⁶) can be used only once)

We list out all powers of 2 & 3 in list `power`. `n` must be represented as sum of no.s in list `power` (for convenience we sort list `power` in descending order).

To form sum `n`, we first select the largest no. that can be included in sum to `n`. We have 2 conditions for that:

1. Only no.s less than `n` in list `power` can be a considered possible for the process.

2. An `i`th element in list `power` can be considered for the process only if sum of no.s in `power` from `i`th position to the end is >= `n` (if `i`th no. is largest in sum to `n`, it should be at least possible to make `n` by summing up all remaining no.s, and any no. in `power` (sorted descending order) coming after this `i`th position cannot be the largest no. in the sum to `n`).

To avoid calculating sum of `power` from `i`th position to end every time, we declare `sum_power` calculated corresponding to each position of `power`.

According to problem statement, `n` can have maximum value of 10⁸, hence we find the maximum power of 2 & 3 in 10⁸ using `power_of_k(n,k)` below:
```
from math import floor
def power_of_k(n,k):
    q=n
    count=0
    while q not in range(k):
        q=floor(q/k)
        count+=1
    return count
```
Value of `power_of_k()` for n=10⁸, k=2 is 26 and k=3 is 16. `power` and `sum_power` is generated by:
```
power = sorted(([pow(2,i) for i in range(27)] + [pow(3,i) for i in range(17)]))[::-1]
sum_power = [sum(power[i:]) for i in range(len(power))]
```
To calculate the minimum count of no.s in `power` that make up `n`, we should not use an already used number. So we pass the list `power` in function call & along with it `sum_power` (we exclude elements from both which are already used or are bigger than no. at hand).

We use `min_count(n,power,sum_power)` to find the minimum count of no.s in `power` used to form `n` where `sum_power` is sum of elements in `power` from respective position to the end.

If `n` is already present in list `power`, then we `return 1`.

If `n` is not in `power`, we choose the largest no. in remaining elements of `power` using logic discussed above.

`lower` - the smallest index (largest no.) in `power` for largest no. in sum to `n` (1)<br>
`upper` - the largest index (smallest no.) in `power` for largest no. in sum to `n` (2)
```
Code Line 14 to 24
```
We do selective recursion to find minimum possible value of `q`.
```
Code Line 25 to 28
```
Eg.  n=33

No.s in bracket are chosen no.s in sum to `n` (powers of 2 or 3).
Minimum count is 2 [32,1].
```
                  33 
    ┌──────────────┼──────────────┐  
  1(32)          6(27)          17(16)
    │        ┌────┴────┐    ┌────┴────┐
   (1)      2(4)      3(3)  8(9)      9(8)
             │         │    │         │
            (2)       1(2) (8)        4(5)
                       │              │
                      (1)             2(3)
                                      │
                                     (2)
```
Maximum count needed to accomplish sum `n` can also be obtained by changing `min()` to `max()` & `q` to -1000 instead of 1000.